let sessionContext = ""; // Holds context loaded from the side panel for the current session.

// Create the context menu item when the extension is installed.
chrome.runtime.onInstalled.addListener(() => {
  chrome.contextMenus.create({
    id: "get-ai-recommendations",
    title: "Get AI Recommendations for selected text",
    contexts: ["selection"]
  });
});

// Listen for a click on our context menu item (for Google Docs, etc.).
chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === "get-ai-recommendations" && info.selectionText) {
    chrome.sidePanel.open({ tabId: tab.id });
    triggerGetRecommendations(info.selectionText);
  }
});

// Listen for messages from content scripts or the side panel.
chrome.runtime.onMessage.addListener((message, sender) => {
    if (message.type === 'GET_RECOMMENDATIONS') {
        chrome.sidePanel.open({ tabId: sender.tab.id });
        triggerGetRecommendations(message.text);
    }
    // New message type to update the session context from the side panel.
    if (message.type === 'UPDATE_CONTEXT') {
        sessionContext = message.context;
        // Optional: notify the user that context was updated.
        chrome.runtime.sendMessage({ type: 'CONTEXT_UPDATED', status: `Context loaded (${message.context.length} characters).` });
    }
});

// Central function to call the AI.
function triggerGetRecommendations(text) {
    chrome.runtime.sendMessage({ type: 'SHOW_LOADING' });

    // Important: Now it checks for sessionContext first, then falls back to storage.
    chrome.storage.sync.get(['apiKey', 'contextContent'], async (result) => {
        const { apiKey } = result;
        const permanentContext = result.contextContent;
        const activeContext = sessionContext || permanentContext || "";

        if (!apiKey) {
            chrome.runtime.sendMessage({ type: 'SHOW_ERROR', error: 'API Key not set. Please set it in the options.' });
            return;
        }

        let prompt = `You are an expert writing assistant. A user has provided a piece of text and needs help with the next sentence. Your task is to provide three distinct, creative, and contextually relevant suggestions for the sentence that should follow the provided text. The user's text is: "${text}"`;

        if (activeContext) {
            prompt += `\n\nAlso, consider this additional context provided by the user:\n---CONTEXT---\n${activeContext}\n---END CONTEXT---`;
        }

        prompt += `\n\nGenerate three suggestions. IMPORTANT: Your entire response must be ONLY a single, valid JSON array of strings, with no other text or explanations. Example: ["First suggestion.", "Second suggestion.", "A third, different idea."]`

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };

        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}. Check your API Key in the options.`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0) {
                const rawText = result.candidates[0].content.parts[0].text;
                const cleanedText = rawText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');
                const suggestions = JSON.parse(cleanedText);
                chrome.runtime.sendMessage({ type: 'SHOW_RECOMMENDATIONS', data: suggestions });
            } else {
                 throw new Error("No suggestions were generated by the AI.");
            }
        } catch (error) {
            chrome.runtime.sendMessage({ type: 'SHOW_ERROR', error: error.message });
        }
    });
}

// Open side panel when the user clicks the extension's toolbar icon.
chrome.action.onClicked.addListener((tab) => {
    chrome.sidePanel.open({ tabId: tab.id });
});
